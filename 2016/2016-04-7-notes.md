# Symfony Live Paris 2016

## Keynote d'ouverture
Par Fabien Potencier @fabpot (CEO, Blackfire.io, Fondateur de Symfony1/2/3, +++)

Il a parler du processus de contribution et de livraison de Symfony2

En partant du postulat suivant:
  * Le processu de développement est totalement indépendant du processus de livraison

Des lors deux choix s'offrent ave GIT
  * Un repository par projet aka Multi repository
  * Un repository unique qui porte tous les sous-projets aka mono-repository

Le mono-repository offre certains avantages pour le développement
  * refactoring simple, on peut tout faire en une Pull Request
  * Plan de tag simple ou chaque projet suit un versionning commun
  * gestion de dépendences internes simple
  * suite de test simple à jouer

Le multi-repository offre aussi certains avantages:
  * contrôle d'accès simple à chaque sous-projets
  * isolation des composants

Symfony2 utilise les deux méthode en même temps!!
  * 1 mono-repository qui prends tous les composants https://github.com/symfony/symfony/
  * Chaque composant à aussi son propre repository https://github.com/symfony/console

En tous 44 repository!!
  * Le mono-repository est le maitre. Toute évolution est commité dans ce repo (dans les 5 branches qui sont maintenus!)
  * A Chaque merge dans symfony/symfony avec git subtree split les 43 autres repos sont mis à jour, soit env 220 split à chaque merge request

Les développeurs travaillent soit dans sous-projets en 'read-only' soit dans symfony/symfony
puis les merge request sont appliqué systématiquement dans les X branches maintenus symfony/symfony

Fabien à souligné l'importance de l'outillage, toutes ces opérations ne sont pas faite à la main,
mais encapsulé dans une commande maison 'gh' qui pilote completement le processus

gh :
  * reroute une PR depuis un sub-repo vers le mono-repository
  * la pr est évaluer pour typo, commentaires, eval statique, présence de test unitaires
  * la pr passe dans l'intégration continu ou les suites de tests unitaires et d'intégration sont exécuté
  * Créer autant de PR que de branches maintenus
  * Aide à reformater le message de commit qui respecte une sémantique (qui sert à générer les changelog)
  * split le mono-repository pour mettre à jour les repo read-only

Passer du temps sur le tooling, c'est gagner du temps à long terme, c'est rendre éfficace sont workflow

## Guard dans la vraie vie
Par Jeremy Romey @jeremyfreeagent (SensioLabs)

Guard est un nouveau composant de sécurité dans Symfony2.8+
  * see https://github.com/symfony/security-guard

Il n'apporte aucune nouvelle feature, mais c'est une facade qui simplifie/unifie
le processus d'authentification.

Avec Guard connecter un nouveau mode d'authentification c'est juste une classe à implémenter,
avec 6 méthodes, et c'est fini, pas de listener, d'authentication provider et autre joyeuseté

Il encapsule les 4 étapes de l'authentication à un seul endroit:

```php
interface GuardAuthenticatorInterface extends AuthenticationEntryPointInterface
{
    public function getCredentials(Request $request);
    public function getUser($credentials, UserProviderInterface $userProvider);
    public function checkCredentials($credentials, UserInterface $user);
    public function createAuthenticatedToken(UserInterface $user, $providerKey);
    public function onAuthenticationFailure(Request $request, AuthenticationException $exception);
    public function onAuthenticationSuccess(Request $request, TokenInterface $token, $providerKey);
    public function supportsRememberMe();
}
```

## R2D2 to BB8
Par Vincent CHALAMON (Les-Tilleuls.coop) @vincentchalamon

Présentation retour d'expérience sur la refonte de The Fork Manager, un outil de Lafourchette
  * https://www.theforkmanager.com

Etat de départ:
  * Une très grosse codebase, en Symfony 2.0
  * Un très gros volume de donnée
  * Dette technique estimé à 38 ans !

Les containtes:
  * Impossible de perdre de la donnée,
  * Pas de down-time accepté pour migrer les données (migration en one shot estimé à 15j de traitement)
  * On va vers Symfony3

Solution :
  * La migration progressive
    * La codebase legacy reste tel qu'elle est
    * on crée une API REST pont entre la nouvelle monture et l'ancienne
    * les données sont migrés vers le nouveau schéma pendant les INSERT/UPDATE

Implémentation :
  * Loader : Le loader à la charge de migrer une entité de l'ancien schéma vers le nouveau
  * Transformer : Quand un objet est écrit dans la nouvelle bdd, on met aussi a jour l'ancienne
    * l'ancien record se présente comme un proxy vers le nouveau pour que l'ancienne app reste fonctionnel

 C'est les bases d'un ETL (Extract/Transform/Load) maison,


## PHP Meminfo ou la chasse aux memory leak
Par Benoit Jaquemont @bjaquemont DT chez Akeneo (ex DT Smile Group)

### Présentation du memory leak

Un memory leak est un emplacement mémoire qui n'est jamais libéré par PHP

Symptomes:
  * le traitement est de plus en plus lent avec le temps
  * le traitement prends énormément de mémoire

Pourquoi?
  * en PHP on ne gére pas la libération de la mémoire (par comme en C)
  * le mécanisme de libération de mémoire de php à des bugs


Libération de la mémoire comment ca marche?

Il y a deux logiques

###  Libération de la mémoire: Le RefCount
php garde un compteur de chaque utilisation d'une valeur (zval dans php), quand ce compteur tombe a zero, la mémoire est immédiatement libéré.

```php
function printText(){
    $text = 'hello'; // zval : { name: text, refcount: 1 }
    echo $text; // zval : { name: text, refcount: 1 }
}

printText();
//après l'execution zval : { name: text, refcount: 0 }
```

cependent parfois il n'arrive pas à reduire le refcount

```php
class Leaker {
    private $attr;

    public function leak(){
        $a = new \DateTime(); // zval : { name: a, refcount: 1 }
        $b = new \DateTime(); // zval : { name: b, refcount: 1 }

        $this->attr = $a;  // zval : { name: a, refcount: 2 }
        $this->attr = $b;  // zval : { name: a, refcount: 2 } { name: b, refcount: 2 } php n'a pas détecté la réaffectation

    }

}

new Leaker()->leak();
//après l'execution
// zval : { name: a refcount: 1 }
// zval : { name: b refcount: 1 }
// ces deux zval ne seront jamais libéré
```

### Libération de la mémoire: Le Circular Reference Garbage Collector

Ce processus dispose d'un buffer de 10000 objet, quand une zval est créer elle est
référencé dans ce buffer, quand le buffer est plein le processus se lance:
  * il va inspecter le buffer et chercher une zval en mémoire référence celle ci, si pas le cas: libération

Probleme:
  * ce processus est lourd, et plus ca va et plus il prends de temps jusqu'au moment ou le CPU passe plus de temps dans le GC qu'a traiter votre code
  * double punission quand le buffer est plein et que rien n'est libéré, chaque nouvelle zval relance le GC!!

### Solution
  * Monitorer vos processus long / infini
  * Jamais de set_memory_limit -1
  * Logger la vitesse de traitement de vos processus (cas des imports, des exports)
  * Eviter les composants statefull

https://github.com/BitOne/php-meminfo (écrit par Benoit Jaquemont)

  * C'est une extension de php qui une fois installé permet de dumper l'état de la mémoire du processus php
  * c'est des commande bash qui permettent d'analyser le dump pour comprendre ce qu'il se passe, voir ne nb d'objet de chaque type en mémoire et comment est organisé la compositions des objets
